<!DOCTYPE html>
<html lang="zh-CN">

<head>
<meta charset="utf-8" />
<meta name="author" content="zhaogaz" />
<meta name="description" content="" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.52" />

<link rel="canonical" href="../../../post/2018/secret-of-design-pattern/">
<base href="" />
<meta property="og:title" content="设计模式的奥义" />
<meta property="og:description" content="2018.12.07 设计模式的奥义 给这个文章起标题之前，我还犹豫了一下，我觉得奥义还是准确的，我自认为已经理解了设计模式的精髓。 我在最开始接触设计模式的时候还" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/2018/secret-of-design-pattern/" /><meta property="article:published_time" content="2018-12-12T00:21:13&#43;08:00"/>
<meta property="article:modified_time" content="2018-12-12T00:21:13&#43;08:00"/>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="设计模式的奥义"/>
<meta name="twitter:description" content="2018.12.07 设计模式的奥义 给这个文章起标题之前，我还犹豫了一下，我觉得奥义还是准确的，我自认为已经理解了设计模式的精髓。 我在最开始接触设计模式的时候还"/>



<meta itemprop="name" content="设计模式的奥义">
<meta itemprop="description" content="2018.12.07 设计模式的奥义 给这个文章起标题之前，我还犹豫了一下，我觉得奥义还是准确的，我自认为已经理解了设计模式的精髓。 我在最开始接触设计模式的时候还">


<meta itemprop="datePublished" content="2018-12-12T00:21:13&#43;08:00" />
<meta itemprop="dateModified" content="2018-12-12T00:21:13&#43;08:00" />
<meta itemprop="wordCount" content="3508">



<meta itemprop="keywords" content="设计模式,编程," />


<link rel="stylesheet" href="css/layout.css" />
<style type="text/css">
body {
  background-color: #FFFFFF;
  color: #404040;
}

a { color: #404040; }

pre {
  background: #c3ffc3;
  border: 1px solid #404040;
  border-radius: 5px;
}

code {
  background: #c3ffc3;
}

blockquote {
  background: #c3ffc3;
  border-left: 3px solid #404040;
}

table {
  margin: 1em auto;
  border-collapse: collapse;
}

table, th, td {
  border: 1px solid #404040;
}

th {
  background: #404040;
  color: #FFFFFF;
}

.siteTitle a { color: #83ca3d; }

.post .content h1{ color: #83ca3d; }
.post .content h2{ color: #83ca3d; }
.post .content h3{ color: #83ca3d; }
.post .content h4{ color: #83ca3d; }
.post .content h5{ color: #83ca3d; }
.post .content h6{ color: #83ca3d; }
.post .content a:hover { color: #83ca3d; }
.social-link:hover { color: #83ca3d; }
.nav-item-title:hover { color: #83ca3d; }
.tag a:hover { color: #83ca3d; }
.copyright { color: #404040 }
.poweredby { color: #404040 }
.poweredby a { color: #404040; }
.post-preview .title a{ color: #83ca3d; }
.content-item a:hover{
  text-decoration: underline;
  color: #83ca3d;
}
.post-list .title { color: #83ca3d; }
.rmore { color: #83ca3d; }
.terms .term a:hover {
  text-decoration: underline;
  color: #83ca3d;
}

</style>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-114396712-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<title>


     设计模式的奥义 

</title>

<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="">ZhaoGaz&#39;s Blog</a>
    </div> 

    
    
    <a class="nav-item" href="../../../post/"><div class="nav-item-title">Posts</div></a>
    
    <a class="nav-item" href="../../../tags/"><div class="nav-item-title">Tags</div></a>
    
    <a class="nav-item" href="../../../about/"><div class="nav-item-title">About</div></a>
    

  </nav>
</div>

  
<div class="social-links-header">



</div>


</header>


<article class="post">
    <h1 class="title"> 设计模式的奥义 </h1>
    <div class="content"> 

<h1 id="2018-12-07-设计模式的奥义">2018.12.07 设计模式的奥义</h1>

<p>给这个文章起标题之前，我还犹豫了一下，我觉得奥义还是准确的，我自认为已经理解了设计模式的精髓。</p>

<p>我在最开始接触设计模式的时候还是很迷茫的，不知道怎么回事。并且当时以为设计模式能够解决我的问题，到现在为止1年多过去了。我对设计模式有了更深刻的理解，而且核心的理解没有大变化，而且我不认为之后会有大的变化.</p>

<p>当然，我的学习过程中还产生过与<code>MVC设计模式</code>纠缠的问题，不过现在已经搞清了，这些东西描述的层级是不一样的。就像说城镇指的是一个地方，说国家也指的是一个地方，但是理解的层次是不同的。设计模式指的是更细节的东西，而<code>MVC</code>这种指的是整个项目的。</p>

<p>不过坦诚讲，我觉得王垠说的是对的，这个四人帮提出的23种设计模式，唬人的成分更大。看起来高级的不行，实际上核心的思路就那么几条。有些人就是故意把一些很简单的东西说的很困难，同时也让别人觉得很困难。</p>

<blockquote>
<p>一天有人跟你说，屎真香，尝一口吧。然后你忍不住，真的尝了一口，你俩相视一笑。，也开始见人就说屎真香。</p>
</blockquote>

<p>到目前为止，在java中<code>Abstruct</code> 和<code>Implement</code>的区别差距非常小，在大部分场景下都可以互相替换，区别多在于class的extend和 interface 的 implements。</p>

<p>函数式接口的大量补充，让interface 也具有了默认方法的功能，这两种东西差距更小了。所以我在文中会故意忽略这两种东西,因为没啥区别.而且我印象中查<code>stof</code>说的也是这个意思.</p>

<h2 id="设计模式的核心">设计模式的核心</h2>

<p>以下几条是我总结出来的设计模式的核心概念,不管设计模式说什么原则,什么概念,有这几个核心的技巧,就能理解所有的设计模式了.</p>

<p>最核心的内容就是<code>接口</code>,除此之外,还有几个技巧值得一说.然后就没什么可说的了。</p>

<h3 id="接口">接口</h3>

<p>设计模式的核心就是接口，原本AB两个东西混在一起，现在通过一个接口C，把AB拆解开，让AC混在一起，B实现C。</p>

<p>C这个接口就相当于一个约束，规定了某些行为。满足行为的任何东西都可以。所以在A看来，任何满足条件C的东西，都可以。</p>

<p>有了这样的理解之后，设计模式的大部分东西都没有必要看了。因为绝大部分都是这个思想，然后起个高大上的名字。</p>

<p>这种接口概念的延伸就是用3号来把12拆开,让13和 23产生关系.就像<code>中介者模式</code>,就算没有用到接口,也实现了两者的分开.不过概念和接口是一样的,用第三者来应对改变.</p>

<blockquote>
<p>2018.12.12补充,最近在搞博客的时候,CNAME也是这个配置思路.别人的ip被别人的域名隐藏起来了,然后我们改动的时候使用CNAME,如果没有CNAME这个第三者,别人IP改变的时候就麻烦多了.</p>
</blockquote>

<h3 id="技巧1">技巧1</h3>

<p>在接口或者是父类什么地方，规定调用几个内部的接口，一部分要求子类改，一部分阻止子类修改。这个技巧很有意思，在<code>HashMap</code>的源码中也有出现.</p>

<p>这个技巧的核心是自己调用自己的某些方法，被调用的某些方法<strong>可以</strong>被子类修改。注意这里说的是可以，这里面的抽象类是必须修改，在hashmap源码中也可以改成可选的。强制都必须要修改就是所谓的<em>模版模式</em></p>

<pre><code class="language-java">public abstract class Game {
//子类需要重写的方法
   abstract void initialize();
   abstract void startPlay();

//子类不可改变的方法
   public final void play(){
      initialize();
      startPlay();
   }
}
</code></pre>

<h3 id="技巧2-我帮你做">技巧2——我帮你做</h3>

<p>A类型 内部持有一个其他的对象B，具体怎么持有的无所谓，甭管是类初始化，还是什么时候放进去的。</p>

<p>然后就可以调用其他对象B的方法了。如果AB实现了相同的接口（当然要加A自己的私货了，完全一样有用么？），就叫做*装饰器*。如果实现的不同接口，叫做<em>适配器</em>,*策略模式*同理。（喷了，完全一样叫做*代理模式*，翻到代理模式才看到）</p>

<p>AB类型实现了相同接口，同时，内部有一堆B的话，叫做*组合*。或<em>解释器</em>(当然稍有差别)</p>

<p>这种包装的技巧有点意思。</p>

<h3 id="技巧3-调用反转">技巧3&mdash;-调用反转</h3>

<p>原本使用的时候是A对象,调用B对象.<code>A.aa(B)</code></p>

<p>但是通过如下接口抽象,能让<code>B.bb(A)</code>实现一样的功能,做法就是把A改成接口,让真实的A来实现,在bb方法内部调用<code>A.aa(this)</code>这样就实现了调用的反转.</p>

<p>这就是*访问者模式*的核心了.</p>

<p>*状态模式*同上</p>

<p>这个技巧表面上看起来是翻转了调用,实际上,还要调用回来的.只不过人们都认为调用接口是解耦,就是这么回事.</p>

<h3 id="技巧4-观察者">技巧4&mdash;-观察者</h3>

<p>观察者的核心其实也是上面这个技巧3,只不过做了一些扩展.这种反转控制的行为能造成一种通知的效果,观察的人会得到通知.</p>

<p>怎么得到呢?在通知的人身上进行注册,注册的技巧就是上面说的调用反转.所以最后就实现了,观察者调用一个方法,入参是 通知的人.</p>

<p>通知的人发一个消息,观察者的某些行为就会被触发.</p>

<p>在最开始学设计模式的时候,对这个印象非常深,现在看来就是一个 利用接口的调用反转.</p>

<h3 id="技巧5-内部类接口">技巧5&mdash;-内部类接口</h3>

<p>在类中,写一个私有的内部类,让这个内部类实现一个接口,在类中提供一个方法返回这个内部类.</p>

<p>这就是内部类设计的真实含义</p>

<p>这个技巧可以不暴露内部的对象的同时,仅仅是获得一个接口实现.</p>

<p>内部类就是干这个用的.但是在设计模式中却变成了迭代器模式</p>

<h3 id="命名">命名</h3>

<p>额外的一点好处就是命名了，老外起名字还是很准确的。一看到<code>xxxFactory</code>你就知道是工厂了，好处也就是这个了吧。</p>

<h2 id="点评">点评</h2>

<p>下面分别对这些做一些点评，总感觉人家都提出来了23个，某些东西什么都不说也不好。</p>

<h3 id="单例">单例</h3>

<p>全局惟一一个怎么办呢？</p>

<p>很简单，私有化构造器，不让别人轻易地初始化，自己提供一个静态方法，提供唯一的静态对象。</p>

<p>单例的操作确实是一种范式.</p>

<h3 id="工厂">工厂</h3>

<p>定义了商品的行为，抽出一样的接口。</p>

<h3 id="抽象工厂">抽象工厂</h3>

<p>除了定义商品行为的接口，还定义了工厂的接口。你看，还是接口吧。</p>

<h3 id="建造者">建造者</h3>

<p>真是封装了一下复杂对象的初始化。连设计模式都算不上吧，这个东西标准设计模式还要要求你抽接口，实际上就看需求了。</p>

<h3 id="原型">原型</h3>

<p>clone一下，有啥可说的？不就是复用半成品的对象而已。</p>

<h3 id="适配器">适配器</h3>

<p>见上文</p>

<h3 id="桥接">桥接</h3>

<p>就是把两个接口搞一起了，大家都用接口，随便换。</p>

<h3 id="组合">组合</h3>

<p>这东西也叫做设计模式？那不就是随手写的东西么？这属于OOP基础了.</p>

<h3 id="装饰器">装饰器</h3>

<p>这个上面说过了，抽象类写不写无所谓的。</p>

<h3 id="外观模式">外观模式</h3>

<p>把一堆对象扔到一起，然后让别人调用。按照这个逻辑讲的话，绝大部分代码都是外观模式了。</p>

<h3 id="享元模式">享元模式</h3>

<p>这个东西叫做 缓存技术更恰当吧，也是接口，统一相同的对象，缓存起来。</p>

<h3 id="代理">代理</h3>

<p>上面说了。</p>

<h3 id="访问者模式">访问者模式</h3>

<p>把两个接口混合在一起互相调用,原本是<code>a.xx(b)</code>,(a是参观者),(b是被调用的)但是改成了<code>b.xxx(a)</code>在b的内部为<code>a.xx(this)</code> 就反转了方法调用.</p>

<h3 id="模板模式">模板模式</h3>

<p>说过了</p>

<h3 id="策略模式">策略模式</h3>

<p>同上</p>

<h3 id="状态模式">状态模式</h3>

<p>同上文</p>

<h3 id="观察者模式">观察者模式</h3>

<p>同上文</p>

<h3 id="备忘录模式">备忘录模式</h3>

<p>就是使用一个类缓存了一下状态，这种也能称之为设计模式？</p>

<h3 id="中介者模式">中介者模式</h3>

<p>就是想办法找一个类,对接两个相同的类型.具体怎么操作都无所谓,反正结果就是,AB原本互相有关系,现在变成了只和中介有关系了.</p>

<h3 id="迭代器模式">迭代器模式</h3>

<p>这个很常规，类库内部有实现. 这个技巧我不能把它说成是设计模式,我只能说是内部类的技巧。</p>

<h3 id="解释器">解释器</h3>

<p>大家都实现同一个解释规则,某些复杂规则可以通过简单的规则组合起来.本质上和装饰器适配器差不多.</p>

<h3 id="命令模式">命令模式</h3>

<p>看成中介,或者是代理,完全没有任何问题,只不过执行的东西是一个对象,即要调用对象的某些方法才算是执行,而实际的执行方法已经写死到了接口实现中.没有本质区别</p>

<h3 id="责任链模式">责任链模式</h3>

<p>在接口中预设,其他的调用对象,实现类中,调用这个对象进行实现.即责任链,实现的效果就是一层套一层,可以自己手动制定调用多少层. 反正都是接口嘛.</p>

<h2 id="备注与总结">备注与总结</h2>

<p>这里会说一些额外的点,一些常用的误会.也顺便做一些总结吧.</p>

<p>我对设计模式的理解就是这样了,核心的内容就是那么几个,</p>

<p>而且我印象中好像还有什么,迪米特里原则,里氏替换原则,依赖倒置什么的各种原则,这些原则都不重要.</p>

<p>只要是编码水平正常,封装多态什么的都不是设计模式要考虑的问题.以上的原则都不重要.</p>

<p>还有一点想提的就是,《java编程思想》这本书比普通编程入门书难读的原因就是，因为里面融合了很多设计模式的东西。这本书还套了很多的概念和模型。理解起来确实比普通的数费力一些。</p>

<ol>
<li>java的代理和代理模式不是一个东西，java的代理是一种实现，一种具体的做法，这个做法没有用到代理的设计模式。</li>
<li>MVC、MVVM和这里面说的设计模式不是一个事情。上文已经解释了.</li>
<li>很多代码都可以套上设计模式,但实际上使用者并没有 有意识的用这些模式,实质上模式不是用来套的,这种设计模式是总结出来的产物.</li>
<li>mybatis源码中，经常需要调用xxx.builder() 来初始化对象。这个东西和标准的建造者设计模式还不一样，不好混为一谈。</li>
<li>实际工作当中最常见的设计模式就有几个，大部分都不是很常用</li>
<li>很多设计模式是非常相似的，区别不是很明显，强行说xxx是某某设计模式是合适的，而且设计模式之间不应该有对比，即便他们都是设计模式。</li>
</ol>
 </div>
    <footer class="post-footer">

  <div class="post-footer-data">
    
<div class="tags">
    
      <div class="tag">
        <a href="../../../tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">#设计模式</a>
      </div>
    
      <div class="tag">
        <a href="../../../tags/%E7%BC%96%E7%A8%8B">#编程</a>
      </div>
    
</div>

    <div class="date"> Dec 12, 2018 </div>
  </div>

</footer>


  


</article>

  <footer>

  <div class="social-links-footer">

  
  <a href="mailto:zx12_zx12@126.com"><div class="social-link">Email</div></a>
  

  
  <a href="https://github.com/angrydisk" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  

  

  <div class="social-link">
  <a href="../../../index.xml" target="_blank">RSS</a>
  </div>

</div>


  <div class="copyright">  </div>

  <div class="poweredby">
    Powered by <a href="https://gohugo.io/">Hugo</a>.
  </div>

  </footer>

</div> 

</body>
</html>

